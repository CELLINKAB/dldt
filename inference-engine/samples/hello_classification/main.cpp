// Copyright (C) 2018-2019 Intel Corporation
// SPDX-License-Identifier: Apache-2.0
//

#include <vector>
#include <memory>
#include <string>
#include <chrono>
#include <dirent.h>

#include <samples/common.hpp>

#ifdef UNICODE
#include <tchar.h>
#endif

#include <inference_engine.hpp>
#include <samples/ocv_common.hpp>
#include <samples/classification_results.h>

using namespace InferenceEngine;

#ifndef UNICODE
#define tcout std::cout
#define _T(STR) STR
#else
#define tcout std::wcout
#endif

void classifyImage(const file_name_t& input_image_path, CNNNetwork& network, ExecutableNetwork& executable_network) {
        
        // --------------------------- 5. Create infer request -------------------------------------------------
        InferRequest infer_request = executable_network.CreateInferRequest();

        // --------------------------- 6. Prepare input --------------------------------------------------------
        /* Read input image to a blob and set it to an infer request without resize and layout conversions. */
        cv::Mat originalImage = cv::imread(input_image_path);
        // Grayscale & resize image to fit the dimensions that the model is trained for
        cv::Mat image;
        cv::cvtColor(originalImage, image, cv::COLOR_BGR2GRAY);

        cv::Mat resizedImage;
        cv::resize(image, resizedImage, cv::Size(224, 224), 0, 0, cv::INTER_LINEAR);

        // Convert a vector/matrix of unsigned 8-bit int values (between 0-255)
        // to 32-bit float values (between 0-1)
        cv::Mat convertedImage;
        resizedImage.convertTo(convertedImage, CV_32FC1, 1 / 255.0);

        //Blob::Ptr imgBlob = wrapMat2Blob(image);  // just wrap Mat data by Blob::Ptr without allocating of new memory
        InferenceEngine::TensorDesc tDesc(InferenceEngine::Precision::FP32,
                                            {1, (long unsigned int)convertedImage.channels(), (long unsigned int)convertedImage.size().height, (long unsigned int)convertedImage.size().width},
                                            InferenceEngine::Layout::NHWC);
        Blob::Ptr imgBlob = make_shared_blob<float>(tDesc, reinterpret_cast<float*>(convertedImage.data));

        std::string input_name = network.getInputsInfo().begin()->first;
        infer_request.SetBlob(input_name, imgBlob);  // infer_request accepts input blob of any size
        // -----------------------------------------------------------------------------------------------------

        // --------------------------- 7. Do inference --------------------------------------------------------
        /* Running the request synchronously */
        std::chrono::steady_clock::time_point begin = std::chrono::steady_clock::now();
        infer_request.Infer();
        std::chrono::steady_clock::time_point end = std::chrono::steady_clock::now();
        // -----------------------------------------------------------------------------------------------------

        // --------------------------- 8. Process output ------------------------------------------------------
        
        std::string output_name = network.getOutputsInfo().begin()->first;
        Blob::Ptr output = infer_request.GetBlob(output_name);

        // Print classification results
        ClassificationResult classificationResult(output, {fileNameToString(input_image_path)}, 1, 2, {"yes", "no"});
        classificationResult.print();
        std::cout << "Time difference = " << std::chrono::duration_cast<std::chrono::milliseconds>(end - begin).count() << "[ms]" << std::endl;
        // -----------------------------------------------------------------------------------------------------
}

#ifndef UNICODE
int main(int argc, char *argv[]) {
#else
int wmain(int argc, wchar_t *argv[]) {
#endif
    try {
        // ------------------------------ Parsing and validation of input args ---------------------------------
        if (argc != 4) {
            tcout << _T("Usage : ./hello_classification <path_to_model> <path_to_image> <device_name>") << std::endl;
            return EXIT_FAILURE;
        }

        const file_name_t input_model{argv[1]};
        const file_name_t input_path{argv[2]};
        const std::string device_name{argv[3]};

        // -----------------------------------------------------------------------------------------------------

        // --------------------------- 1. Load inference engine instance -------------------------------------
        Core ie;
        // -----------------------------------------------------------------------------------------------------

        // --------------------------- 2. Read IR Generated by ModelOptimizer (.xml and .bin files) ------------
        CNNNetReader network_reader;
        network_reader.ReadNetwork(fileNameToString(input_model));
        network_reader.ReadWeights(fileNameToString(input_model).substr(0, input_model.size() - 4) + ".bin");
        network_reader.getNetwork().setBatchSize(1);
        CNNNetwork network = network_reader.getNetwork();
        // -----------------------------------------------------------------------------------------------------

        // --------------------------- 3. Configure input & output ---------------------------------------------
        // --------------------------- Prepare input blobs -----------------------------------------------------
        InputInfo::Ptr input_info = network.getInputsInfo().begin()->second;

        /* Mark input as resizable by setting of a resize algorithm.
         * In this case we will be able to set an input blob of any shape to an infer request.
         * Resize and layout conversions are executed automatically during inference */
        //input_info->getPreProcess().setResizeAlgorithm(RESIZE_BILINEAR);

        input_info->setLayout(Layout::NHWC);
        input_info->setPrecision(Precision::FP32);

        // --------------------------- Prepare output blobs ----------------------------------------------------
        DataPtr output_info = network.getOutputsInfo().begin()->second;
        output_info->setPrecision(Precision::FP32);
        // -----------------------------------------------------------------------------------------------------

        // --------------------------- 4. Loading model to the device ------------------------------------------
        ExecutableNetwork executable_network = ie.LoadNetwork(network, device_name);
        // -----------------------------------------------------------------------------------------------------

        DIR *dir;
        struct dirent *ent;
        if ((dir = opendir (input_path.c_str())) != NULL) {
            while ((ent = readdir (dir)) != NULL) {
                std::string filename = std::string(ent->d_name);
                if (filename.substr(filename.find_last_of(".") + 1) == "png") {
                    classifyImage(input_path + "/" + filename, network, executable_network);
                }
            }
            closedir (dir);
        } else {
            classifyImage(input_path, network, executable_network);
        }

    } catch (const std::exception & ex) {
        std::cerr << ex.what() << std::endl;
        return EXIT_FAILURE;
    }
    return EXIT_SUCCESS;
}
